<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sub-Grid Blob Autotile Demo</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { background: #1a1a2e; color: #eee; font-family: system-ui, sans-serif; padding: 20px; }
h1 { margin-bottom: 4px; }
.subtitle { color: #aaa; margin-bottom: 16px; font-size: 14px; line-height: 1.5; }
.subtitle b { color: #ddd; }
.subtitle code { background: #2a2a4e; padding: 1px 5px; border-radius: 3px; font-size: 13px; }

/* Layout */
.controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 12px;
  background: #16213e; padding: 10px 14px; border-radius: 8px; }
.controls label { font-size: 13px; color: #aaa; }
.controls select { background: #1a1a2e; color: #eee; border: 1px solid #444; border-radius: 4px; padding: 3px 6px; }
.controls button { background: #2a3a5e; color: #eee; border: 1px solid #444; border-radius: 4px;
  padding: 4px 10px; cursor: pointer; font-size: 12px; }
.controls button:hover { background: #3a4a7e; }

.main { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
.canvas-wrap { position: relative; }
canvas { cursor: crosshair; border: 1px solid #333; border-radius: 4px; background: #0a0a1a; }

/* Palette */
.palette { display: flex; gap: 6px; align-items: center; }
.palette .swatch { width: 28px; height: 28px; border-radius: 4px; cursor: pointer;
  border: 2px solid transparent; transition: border-color 0.15s; position: relative; }
.palette .swatch:hover { border-color: #fff8; }
.palette .swatch.active { border-color: #fff; box-shadow: 0 0 6px #fff4; }
.palette .swatch .label { position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%);
  font-size: 9px; color: #888; white-space: nowrap; pointer-events: none; }

/* Brush sizes */
.brush-row { display: flex; gap: 4px; align-items: center; }
.brush-btn { width: 32px; height: 32px; border-radius: 4px; cursor: pointer;
  border: 2px solid transparent; background: #2a3a5e; display: flex; align-items: center;
  justify-content: center; font-size: 11px; color: #ccc; }
.brush-btn:hover { background: #3a4a7e; }
.brush-btn.active { border-color: #fff; background: #3a4a7e; }

/* Info panel */
.info { min-width: 280px; max-width: 340px; background: #16213e; border-radius: 8px; padding: 14px;
  font-size: 13px; line-height: 1.6; }
.info h3 { font-size: 14px; margin-bottom: 6px; color: #8af; border-bottom: 1px solid #2a3a5e; padding-bottom: 4px; }
.info .row { display: flex; gap: 8px; margin-bottom: 2px; }
.info .lbl { color: #888; min-width: 70px; }
.info .val { color: #eee; font-family: monospace; }
.info .mask-grid { display: inline-grid; grid-template-columns: repeat(3, 18px); gap: 1px;
  font-family: monospace; font-size: 11px; text-align: center; margin: 4px 0; }
.info .mask-grid .bit { width: 18px; height: 18px; line-height: 18px; border-radius: 2px; }
.info .mask-grid .bit.on { background: #4a7a2a; color: #fff; }
.info .mask-grid .bit.off { background: #333; color: #666; }
.info .mask-grid .bit.center { background: #2a2a4e; color: #888; }
.info .sep { height: 8px; }

/* Presets */
.presets { margin-top: 16px; background: #16213e; border-radius: 8px; padding: 12px 14px; }
.presets h3 { font-size: 14px; margin-bottom: 8px; color: #8af; }
.preset-row { display: flex; gap: 6px; flex-wrap: wrap; }
.preset-btn { background: #2a3a5e; color: #eee; border: 1px solid #444; border-radius: 4px;
  padding: 4px 10px; cursor: pointer; font-size: 12px; }
.preset-btn:hover { background: #3a4a7e; }
.preset-desc { margin-top: 6px; font-size: 12px; color: #999; min-height: 18px; }

/* Reference */
.reference { margin-top: 20px; background: #16213e; border-radius: 8px; padding: 14px; }
.reference h3 { font-size: 14px; margin-bottom: 8px; color: #8af; }
.ref-info { font-size: 12px; color: #888; margin-bottom: 10px; }
.ref-grid { display: grid; grid-template-columns: repeat(12, 56px); gap: 2px; }
.ref-cell { text-align: center; border-radius: 3px; padding: 2px; }
.ref-cell canvas { display: block; margin: 0 auto 2px; border-radius: 2px; }
.ref-cell .mask-num { font-family: monospace; font-size: 10px; color: #aaa; }
.ref-cell.highlight { background: #3a4a7e; }
.ref-cell.unused { opacity: 0.3; }

/* Legend */
.legend { display: flex; gap: 16px; margin: 8px 0 12px; flex-wrap: wrap; font-size: 12px; }
.legend-item { display: flex; align-items: center; gap: 5px; }
.legend-shape { display: inline-block; }
</style>
</head><body>

<h1>Sub-Grid Blob Autotile Demo</h1>
<p class="subtitle">
  Interactive explorer for the <b>double-density sub-grid</b> autotile system.<br>
  Each tile's 8-bit blob mask is read directly from 8 surrounding sub-grid points.<br>
  <b>Corner</b> points (even,even) only affect diagonal bits. <b>Midpoints</b> (mixed parity) control cardinal bits.<br>
  A lone corner does nothing visible (diagonal bits require adjacent cardinals). Midpoints are the fundamental unit.<br>
  <b>Modes:</b> <code>Z</code> Positive (fills in) · <code>X</code> Negative (terrain becomes base, enables reverse sheets) · <code>C</code> Unpaint (erases specific terrain).
  <b>Shapes:</b> <code>1-5</code> for point/2x2/3x3/cross/tile.
</p>

<div class="legend">
  <div class="legend-item">
    <svg width="18" height="18"><rect x="3" y="3" width="12" height="12" rx="2" fill="#6b935f" stroke="#fff8" stroke-width="1.5"/></svg>
    <span>Center (tile terrain)</span>
  </div>
  <div class="legend-item">
    <svg width="18" height="18"><rect x="3" y="5" width="12" height="8" rx="2" fill="#6b935f" stroke="#fff8" stroke-width="1.5" transform="rotate(45 9 9)"/></svg>
    <span>Midpoint (cardinal edge)</span>
  </div>
  <div class="legend-item">
    <svg width="18" height="18"><circle cx="9" cy="9" r="5" fill="#6b935f" stroke="#fff8" stroke-width="1.5"/></svg>
    <span>Corner (diagonal)</span>
  </div>
</div>

<div class="controls">
  <label>Paint:</label>
  <div class="palette" id="palette"></div>
  <span style="color:#444">|</span>
  <label>Base:</label>
  <select id="baseSel"></select>
  <span style="color:#444">|</span>
  <label>Mode:</label>
  <div class="brush-row" id="modeRow">
    <div class="brush-btn active" data-mode="positive" title="Positive: terrain fills in [Z]">+</div>
    <div class="brush-btn" data-mode="negative" title="Negative: terrain becomes base [X]">&minus;</div>
    <div class="brush-btn" data-mode="unpaint" title="Unpaint: erase specific terrain [C]">&times;</div>
  </div>
  <span style="color:#444">|</span>
  <label>Shape:</label>
  <div class="brush-row" id="shapeRow">
    <div class="brush-btn active" data-shape="grid1" title="Single point [1]">&middot;</div>
    <div class="brush-btn" data-shape="grid2" title="2x2 block [2]">2x2</div>
    <div class="brush-btn" data-shape="grid3" title="3x3 block [3]">3x3</div>
    <div class="brush-btn" data-shape="cross" title="Cross pattern [4]">&#10010;</div>
    <div class="brush-btn" data-shape="tile" title="Full tile [5]">&#9632;</div>
  </div>
  <span style="color:#444">|</span>
  <label>Grid:</label>
  <select id="gridSel">
    <option value="2">2x2</option>
    <option value="3" selected>3x3</option>
    <option value="4">4x4</option>
    <option value="5">5x5</option>
  </select>
  <span style="color:#444">|</span>
  <label><input type="checkbox" id="showSheets" checked> Sheets</label>
  <label><input type="checkbox" id="showMasks"> Masks</label>
  <button id="clearBtn">Clear</button>
  <button id="shareBtn">Copy URL</button>
</div>

<div class="main">
  <div class="canvas-wrap">
    <canvas id="canvas"></canvas>
  </div>
  <div class="info" id="info">
    <h3>Hovered Tile</h3>
    <div id="tileInfo"><span style="color:#666">Hover over a tile to see details</span></div>
    <div class="sep"></div>
    <h3>Hovered Point</h3>
    <div id="pointInfo"><span style="color:#666">Hover over a sub-grid point</span></div>
  </div>
</div>

<div class="presets">
  <h3>Presets (click to load)</h3>
  <div class="preset-row" id="presetRow"></div>
  <div class="preset-desc" id="presetDesc"></div>
</div>

<div class="reference">
  <h3>All 47 GM Blob Shapes</h3>
  <div class="ref-info">12x4 grid from ME autotile sheet. Mask number below each tile. Highlighted = currently used by a tile in the interactive grid.</div>
  <div class="ref-grid" id="refGrid"></div>
</div>

<script>
// ===================== DATA =====================

const AB = { N: 1, W: 2, E: 4, S: 8, NW: 16, NE: 32, SW: 64, SE: 128 };

const GM_BLOB_47 = [
  [255,1,0],[239,2,0],[223,3,0],[207,4,0],[127,5,0],[111,6,0],[95,7,0],[79,8,0],
  [191,9,0],[175,10,0],[159,11,0],
  [143,0,1],[63,1,1],[47,2,1],[31,3,1],[15,4,1],[173,5,1],[141,6,1],[45,7,1],
  [13,8,1],[206,9,1],[78,10,1],[142,11,1],
  [14,0,2],[91,1,2],[27,2,2],[75,3,2],[11,4,2],[55,5,2],[39,6,2],[23,7,2],
  [7,8,2],[9,9,2],[6,10,2],[140,11,2],
  [12,0,3],[74,1,3],[10,2,3],[19,3,3],[3,4,3],[37,5,3],[5,6,3],
  [8,7,3],[4,8,3],[1,9,3],[2,10,3],[0,11,3],
];

// mask → {col, row}
const GM_BLOB_MAP = new Map();
for (const [mask, col, row] of GM_BLOB_47) GM_BLOB_MAP.set(mask, { col, row });

function canonicalize(mask) {
  let r = mask & 0x0f;
  if (mask & AB.N && mask & AB.W) r |= mask & AB.NW;
  if (mask & AB.N && mask & AB.E) r |= mask & AB.NE;
  if (mask & AB.S && mask & AB.W) r |= mask & AB.SW;
  if (mask & AB.S && mask & AB.E) r |= mask & AB.SE;
  return r;
}

function fillDiags(mask) {
  let r = mask;
  if (mask & AB.N && mask & AB.W) r |= AB.NW;
  if (mask & AB.N && mask & AB.E) r |= AB.NE;
  if (mask & AB.S && mask & AB.W) r |= AB.SW;
  if (mask & AB.S && mask & AB.E) r |= AB.SE;
  return r;
}

// Full 256-entry lookup
const GM_LOOKUP = new Array(256);
for (let m = 0; m < 256; m++) {
  const c = canonicalize(m);
  let entry = GM_BLOB_MAP.get(c);
  if (!entry) entry = GM_BLOB_MAP.get(fillDiags(c));
  if (!entry) entry = GM_BLOB_MAP.get(0);
  GM_LOOKUP[m] = entry;
}

const TERRAINS = [
  { id: 0, name: "DeepWater",    label: "Deep Water",    color: "#1a3a5c" },
  { id: 1, name: "ShallowWater", label: "Shallow Water", color: "#3a7ab8" },
  { id: 2, name: "Sand",         label: "Sand",          color: "#c2a860" },
  { id: 3, name: "SandLight",    label: "Sand Light",    color: "#d4c888" },
  { id: 4, name: "Grass",        label: "Grass",         color: "#6b935f" },
  { id: 5, name: "DirtLight",    label: "Dirt Light",    color: "#a08050" },
  { id: 6, name: "DirtWarm",     label: "Dirt Warm",     color: "#8b6030" },
];

// Blend pairs: key = my*8+neighbor → { file, inverted, isAlpha }
const BLENDS = new Map();
function addB(my, nb, file, inv, alpha = false) { BLENDS.set(my * 8 + nb, { file, inv, alpha }); }
// Dedicated pairs
addB(0, 1, "me-autotile-16.png", false); addB(1, 0, "me-autotile-16.png", true);
addB(2, 1, "me-autotile-08.png", false); addB(1, 2, "me-autotile-08.png", true);
addB(2, 3, "me-autotile-09.png", false); addB(3, 2, "me-autotile-09.png", true);
addB(3, 4, "me-autotile-07.png", false); addB(4, 3, "me-autotile-07.png", true);
addB(5, 4, "me-autotile-01.png", false); addB(4, 5, "me-autotile-01.png", true);
addB(6, 4, "me-autotile-02.png", false); addB(4, 6, "me-autotile-12.png", false);
addB(1, 4, "me-autotile-03.png", false); addB(4, 1, "me-autotile-15.png", false);
// Alpha fallbacks — matches BlendGraph.ts: no alpha for DirtLight/DirtWarm
// (their only valid blend is with Grass, which has dedicated sheets)
for (let my = 0; my < 7; my++) for (let nb = 0; nb < 7; nb++) {
  if (my === nb || BLENDS.has(my * 8 + nb)) continue;
  let f = null;
  if (my === 4) f = "me-autotile-13.png";           // Grass alpha
  else if (my === 0 || my === 1) f = "me-autotile-13.png"; // Water → grass alpha fallback
  else if (my === 2 || my === 3) f = "me-autotile-10.png"; // Sand alpha
  // DirtLight (5) and DirtWarm (6): NO alpha fallback — hard edge for non-Grass neighbors
  if (f) addB(my, nb, f, false, true);
}
// Base fills: terrain → file (mask 255 = col 1, row 0)
const BASE_SHEET = { 0: "me-autotile-16.png", 1: "me-autotile-03.png", 2: "me-autotile-08.png",
  3: "me-autotile-07.png", 4: "me-autotile-15.png", 5: "me-autotile-01.png", 6: "me-autotile-02.png" };

// ===================== STATE =====================

const CELL = 48; // sub-grid point spacing in pixels
const PAD = 28;  // canvas padding
const POINT_R = { center: 10, mid: 8, corner: 6 }; // point radii

let gridSize = 3;
let sgSize = 2 * gridSize + 1; // sub-grid dimension
let subgrid = new Uint8Array(sgSize * sgSize);
let baseTerrain = 4; // Grass
let paintTerrain = 1; // ShallowWater
let brushMode = "positive"; // "positive" | "negative" | "unpaint"
let brushShape = "grid1";   // "grid1" | "grid2" | "grid3" | "cross" | "tile"
let hoveredPoint = null; // {sx, sy}
let hoveredTile = null;  // {tx, ty}
let painting = false;
let paintButton = 0;
let showSheets = true;
let showMasks = false;

// Sheet images cache
const sheetCache = {};
function getSheet(file) {
  if (sheetCache[file]) return sheetCache[file];
  const img = new Image();
  img.src = file;
  sheetCache[file] = img;
  img.onload = () => render();
  return img;
}

// ===================== UTILITIES =====================

function sgIdx(sx, sy) { return sy * sgSize + sx; }
function getSg(sx, sy) {
  if (sx < 0 || sy < 0 || sx >= sgSize || sy >= sgSize) return baseTerrain;
  return subgrid[sgIdx(sx, sy)];
}
function setSg(sx, sy, val) {
  if (sx >= 0 && sy >= 0 && sx < sgSize && sy < sgSize) subgrid[sgIdx(sx, sy)] = val;
}

function pointType(sx, sy) {
  const xEven = sx % 2 === 0, yEven = sy % 2 === 0;
  if (!xEven && !yEven) return "center";
  if (xEven && yEven) return "corner";
  return "mid";
}

function pointTypeLabel(sx, sy) {
  const t = pointType(sx, sy);
  if (t === "center") return "Center (tile terrain)";
  if (t === "corner") return "Corner (diagonal)";
  // Determine if horizontal or vertical midpoint
  return (sx % 2 === 1) ? "H-midpoint (N/S edge)" : "V-midpoint (W/E edge)";
}

// Canvas coords ↔ sub-grid coords
function sgToCanvas(sx, sy) { return { x: PAD + sx * CELL, y: PAD + sy * CELL }; }
function canvasToSg(cx, cy) {
  const sx = Math.round((cx - PAD) / CELL);
  const sy = Math.round((cy - PAD) / CELL);
  return { sx, sy };
}
function canvasToTile(cx, cy) {
  // Tile (tx,ty) center is at subgrid (2*tx+1, 2*ty+1)
  const tx = Math.floor((cx - PAD) / (CELL * 2));
  const ty = Math.floor((cy - PAD) / (CELL * 2));
  if (tx >= 0 && tx < gridSize && ty >= 0 && ty < gridSize) return { tx, ty };
  return null;
}

// ===================== BRUSH HELPERS =====================

function getBrushPoints(sx, sy) {
  const pts = [];
  switch (brushShape) {
    case "grid1":
      pts.push({ sx, sy });
      break;
    case "grid2":
      for (let dy = 0; dy < 2; dy++)
        for (let dx = 0; dx < 2; dx++)
          pts.push({ sx: sx + dx, sy: sy + dy });
      break;
    case "grid3":
      for (let dy = -1; dy <= 1; dy++)
        for (let dx = -1; dx <= 1; dx++)
          pts.push({ sx: sx + dx, sy: sy + dy });
      break;
    case "cross":
      pts.push({ sx, sy });
      pts.push({ sx: sx - 1, sy });
      pts.push({ sx: sx + 1, sy });
      pts.push({ sx, sy: sy - 1 });
      pts.push({ sx, sy: sy + 1 });
      break;
    case "tile": {
      // Snap to nearest tile center (odd,odd), then paint all 9 subgrid points
      const tcx = sx % 2 === 0 ? (sx > 0 ? sx - 1 : sx + 1) : sx;
      const tcy = sy % 2 === 0 ? (sy > 0 ? sy - 1 : sy + 1) : sy;
      for (let dy = -1; dy <= 1; dy++)
        for (let dx = -1; dx <= 1; dx++)
          pts.push({ sx: tcx + dx, sy: tcy + dy });
      break;
    }
  }
  return pts.filter(p => p.sx >= 0 && p.sy >= 0 && p.sx < sgSize && p.sy < sgSize);
}

function findUnpaintReplacement(sx, sy) {
  const counts = new Map();
  for (const [dx, dy] of [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,-1],[-1,1],[1,1]]) {
    const t = getSg(sx + dx, sy + dy);
    if (t !== paintTerrain) counts.set(t, (counts.get(t) || 0) + 1);
  }
  if (counts.size === 0) return baseTerrain;
  let best = baseTerrain, bestCount = 0;
  for (const [t, c] of counts) {
    if (c > bestCount) { best = t; bestCount = c; }
  }
  return best;
}

// ===================== COMPUTATION =====================

function computeDirectMask(neighbors, terrain) {
  let mask = 0;
  if (neighbors.N  === terrain) mask |= AB.N;
  if (neighbors.W  === terrain) mask |= AB.W;
  if (neighbors.E  === terrain) mask |= AB.E;
  if (neighbors.S  === terrain) mask |= AB.S;
  if (neighbors.NW === terrain) mask |= AB.NW;
  if (neighbors.NE === terrain) mask |= AB.NE;
  if (neighbors.SW === terrain) mask |= AB.SW;
  if (neighbors.SE === terrain) mask |= AB.SE;
  return mask;
}

function computeTileInfo(tx, ty) {
  const cx = 2 * tx + 1, cy = 2 * ty + 1;
  const center = getSg(cx, cy);
  const neighbors = {
    N:  getSg(cx, cy - 1), NE: getSg(cx + 1, cy - 1),
    E:  getSg(cx + 1, cy), SE: getSg(cx + 1, cy + 1),
    S:  getSg(cx, cy + 1), SW: getSg(cx - 1, cy + 1),
    W:  getSg(cx - 1, cy), NW: getSg(cx - 1, cy - 1),
  };

  // Gather unique terrains
  const all = new Set([center, ...Object.values(neighbors)]);

  // Base = lowest depth, unless negative mode forces paintTerrain as base
  let base;
  if (brushMode === "negative" && all.has(paintTerrain)) {
    base = paintTerrain;
  } else {
    base = center;
    for (const t of all) if (t < base) base = t;
  }

  // Overlays sorted by depth ascending
  const overlays = [...all].filter(t => t !== base).sort((a, b) => a - b);

  // Compute blend layers
  const layers = [];
  for (const overlay of overlays) {
    const blend = BLENDS.get(overlay * 8 + base);
    if (!blend) continue;

    let rawMask;
    if (!blend.inv) {
      rawMask = computeDirectMask(neighbors, overlay);
    } else {
      rawMask = computeDirectMask(neighbors, base);
    }
    const mask = canonicalize(rawMask);
    if (mask === 0 && center !== overlay) continue; // Skip unless center IS this overlay (isolated island)
    const sprite = GM_LOOKUP[mask];
    layers.push({ terrain: overlay, rawMask, mask, blend, sprite });
  }

  return { center, base, neighbors, layers, allTerrains: [...all] };
}

// ===================== RENDERING =====================

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  const w = PAD * 2 + (sgSize - 1) * CELL;
  canvas.width = w;
  canvas.height = w;
}

function render() {
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0, 0, w, h);

  // Collect all masks in use (for reference highlighting)
  const usedMasks = new Set();

  // Draw tiles
  for (let ty = 0; ty < gridSize; ty++) {
    for (let tx = 0; tx < gridSize; tx++) {
      drawTile(tx, ty, usedMasks);
    }
  }

  // Draw tile grid lines
  ctx.strokeStyle = "#ffffff18";
  ctx.lineWidth = 1;
  for (let i = 0; i <= gridSize; i++) {
    const p = PAD + i * CELL * 2;
    ctx.beginPath(); ctx.moveTo(p, PAD); ctx.lineTo(p, PAD + (sgSize - 1) * CELL); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(PAD, p); ctx.lineTo(PAD + (sgSize - 1) * CELL, p); ctx.stroke();
  }

  // Draw sub-grid points
  for (let sy = 0; sy < sgSize; sy++) {
    for (let sx = 0; sx < sgSize; sx++) {
      drawPoint(sx, sy);
    }
  }

  // Brush preview on hover
  if (hoveredPoint && !painting) {
    const pts = getBrushPoints(hoveredPoint.sx, hoveredPoint.sy);
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = brushMode === "unpaint" ? "#ff5050" : TERRAINS[paintTerrain].color;
    for (const p of pts) {
      const { x, y } = sgToCanvas(p.sx, p.sy);
      const type = pointType(p.sx, p.sy);
      const r = POINT_R[type] + 3;
      if (type === "center") {
        ctx.fillRect(x - r, y - r, r * 2, r * 2);
      } else if (type === "corner") {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.moveTo(x, y - r);
        ctx.lineTo(x + r, y);
        ctx.lineTo(x, y + r);
        ctx.lineTo(x - r, y);
        ctx.closePath();
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1.0;
  }

  // Highlight hovered tile
  if (hoveredTile) {
    const { tx, ty } = hoveredTile;
    const x = PAD + tx * CELL * 2;
    const y = PAD + ty * CELL * 2;
    ctx.strokeStyle = "#fff4";
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 1, y + 1, CELL * 2 - 2, CELL * 2 - 2);
  }

  // Update reference highlighting
  renderReference(usedMasks);
}

function drawTile(tx, ty, usedMasks) {
  const info = computeTileInfo(tx, ty);
  const x = PAD + tx * CELL * 2;
  const y = PAD + ty * CELL * 2;
  const size = CELL * 2;

  // Base fill
  ctx.fillStyle = TERRAINS[info.base].color;
  ctx.fillRect(x, y, size, size);

  if (showSheets) {
    // Draw base fill from sheet (mask 255 = col 1, row 0)
    const baseFile = BASE_SHEET[info.base];
    if (baseFile) {
      const img = getSheet(baseFile);
      if (img.complete && img.naturalWidth) {
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, 1 * 16, 0 * 16, 16, 16, x, y, size, size);
      }
    }

    // Draw blend layers
    for (const layer of info.layers) {
      usedMasks.add(layer.mask);
      if (!layer.sprite) continue;
      const img = getSheet(layer.blend.file);
      if (img.complete && img.naturalWidth) {
        ctx.imageSmoothingEnabled = false;
        if (layer.blend.alpha) ctx.globalAlpha = 0.7;
        ctx.drawImage(img, layer.sprite.col * 16, layer.sprite.row * 16, 16, 16, x, y, size, size);
        ctx.globalAlpha = 1.0;
      }
    }
  } else {
    // Color mode: draw mask regions
    for (const layer of info.layers) {
      usedMasks.add(layer.mask);
      const c = TERRAINS[layer.terrain].color;
      const m = layer.mask;
      const s3 = size / 3;
      ctx.fillStyle = c;
      if (m & AB.N)  ctx.fillRect(x + s3, y, s3, s3);
      if (m & AB.W)  ctx.fillRect(x, y + s3, s3, s3);
      if (m & AB.E)  ctx.fillRect(x + size - s3, y + s3, s3, s3);
      if (m & AB.S)  ctx.fillRect(x + s3, y + size - s3, s3, s3);
      if (m & AB.NW) ctx.fillRect(x, y, s3, s3);
      if (m & AB.NE) ctx.fillRect(x + size - s3, y, s3, s3);
      if (m & AB.SW) ctx.fillRect(x, y + size - s3, s3, s3);
      if (m & AB.SE) ctx.fillRect(x + size - s3, y + size - s3, s3, s3);
      // Center always filled if any cardinal
      if (m & 0x0f) ctx.fillRect(x + s3, y + s3, s3, s3);
    }
  }

  // Mask label
  if (showMasks && info.layers.length > 0) {
    const maskStr = info.layers.map(l => l.mask).join(",");
    ctx.fillStyle = "#fff";
    ctx.font = "bold 11px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(maskStr, x + size / 2, y + size / 2);
  }
}

function drawPoint(sx, sy) {
  const terrain = getSg(sx, sy);
  const { x, y } = sgToCanvas(sx, sy);
  const type = pointType(sx, sy);
  const r = POINT_R[type];
  const isHovered = hoveredPoint && hoveredPoint.sx === sx && hoveredPoint.sy === sy;
  const drawR = isHovered ? r + 2 : r;

  ctx.fillStyle = TERRAINS[terrain].color;
  ctx.strokeStyle = isHovered ? "#fff" : "#ffffff60";
  ctx.lineWidth = isHovered ? 2 : 1;

  if (type === "center") {
    // Square
    ctx.fillRect(x - drawR, y - drawR, drawR * 2, drawR * 2);
    ctx.strokeRect(x - drawR, y - drawR, drawR * 2, drawR * 2);
  } else if (type === "corner") {
    // Circle
    ctx.beginPath();
    ctx.arc(x, y, drawR, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  } else {
    // Diamond for midpoints
    ctx.beginPath();
    ctx.moveTo(x, y - drawR);
    ctx.lineTo(x + drawR, y);
    ctx.lineTo(x, y + drawR);
    ctx.lineTo(x - drawR, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

// ===================== INFO PANEL =====================

function updateInfo() {
  const tileDiv = document.getElementById("tileInfo");
  const pointDiv = document.getElementById("pointInfo");

  if (hoveredTile) {
    const { tx, ty } = hoveredTile;
    const info = computeTileInfo(tx, ty);
    let html = "";
    html += `<div class="row"><span class="lbl">Position:</span><span class="val">(${tx}, ${ty})</span></div>`;
    html += `<div class="row"><span class="lbl">Center:</span><span class="val" style="color:${TERRAINS[info.center].color}">${TERRAINS[info.center].label}</span></div>`;
    html += `<div class="row"><span class="lbl">Base:</span><span class="val" style="color:${TERRAINS[info.base].color}">${TERRAINS[info.base].label} (depth ${info.base})</span></div>`;
    if (brushMode !== "positive") {
      html += `<div class="row"><span class="lbl">Mode:</span><span class="val" style="color:${brushMode === "negative" ? "#c84" : "#f55"}">${brushMode}${brushMode === "negative" ? " (" + TERRAINS[paintTerrain].label + " as base)" : ""}</span></div>`;
    }

    if (info.layers.length === 0) {
      html += `<div style="color:#666; margin-top:4px">No blends (uniform neighbors)</div>`;
    }
    for (const layer of info.layers) {
      const t = TERRAINS[layer.terrain];
      const blend = layer.blend;
      html += `<div style="margin-top:6px; border-top:1px solid #2a3a5e; padding-top:4px">`;
      html += `<div class="row"><span class="lbl">Overlay:</span><span class="val" style="color:${t.color}">${t.label}</span></div>`;
      html += `<div class="row"><span class="lbl">Sheet:</span><span class="val">${blend.file.replace("me-autotile-", "#").replace(".png", "")}${blend.inv ? " (inverted)" : ""}${blend.alpha ? " (alpha)" : ""}</span></div>`;
      html += `<div class="row"><span class="lbl">Raw mask:</span><span class="val">${layer.rawMask} → canon: ${layer.mask}</span></div>`;
      if (layer.sprite) {
        html += `<div class="row"><span class="lbl">Sprite:</span><span class="val">col ${layer.sprite.col}, row ${layer.sprite.row}</span></div>`;
      }
      html += maskGridHtml(layer.mask);
      html += `</div>`;
    }
    tileDiv.innerHTML = html;
  } else {
    tileDiv.innerHTML = `<span style="color:#666">Hover over a tile</span>`;
  }

  if (hoveredPoint) {
    const { sx, sy } = hoveredPoint;
    const terrain = getSg(sx, sy);
    const type = pointTypeLabel(sx, sy);
    let html = "";
    html += `<div class="row"><span class="lbl">Sub-grid:</span><span class="val">(${sx}, ${sy})</span></div>`;
    html += `<div class="row"><span class="lbl">Type:</span><span class="val">${type}</span></div>`;
    html += `<div class="row"><span class="lbl">Terrain:</span><span class="val" style="color:${TERRAINS[terrain].color}">${TERRAINS[terrain].label}</span></div>`;
    // Show which tiles this point affects
    const affects = [];
    const pt = pointType(sx, sy);
    if (pt === "center") {
      affects.push(`tile (${(sx-1)/2}, ${(sy-1)/2})`);
    } else if (pt === "corner") {
      // Affects up to 4 tiles as diagonal
      for (const [dx, dy, dir] of [[-1,-1,"SE"], [1,-1,"SW"], [-1,1,"NE"], [1,1,"NW"]]) {
        const tx2 = (sx + dx - 1) / 2, ty2 = (sy + dy - 1) / 2;
        if (tx2 >= 0 && tx2 < gridSize && ty2 >= 0 && ty2 < gridSize)
          affects.push(`(${tx2},${ty2}) as ${dir}`);
      }
    } else {
      // Midpoint: affects 2 tiles as cardinal
      if (sx % 2 === 1) { // H-midpoint (odd x, even y) → N/S
        const tx2 = (sx - 1) / 2;
        if (sy > 0) { const ty2 = (sy - 2) / 2; if (ty2 >= 0 && ty2 < gridSize) affects.push(`(${tx2},${ty2}) as S`); }
        if (sy < sgSize - 1) { const ty2 = sy / 2; if (ty2 >= 0 && ty2 < gridSize) affects.push(`(${tx2},${ty2}) as N`); }
      } else { // V-midpoint (even x, odd y) → W/E
        const ty2 = (sy - 1) / 2;
        if (sx > 0) { const tx2 = (sx - 2) / 2; if (tx2 >= 0 && tx2 < gridSize) affects.push(`(${tx2},${ty2}) as E`); }
        if (sx < sgSize - 1) { const tx2 = sx / 2; if (tx2 >= 0 && tx2 < gridSize) affects.push(`(${tx2},${ty2}) as W`); }
      }
    }
    if (affects.length > 0) {
      html += `<div class="row"><span class="lbl">Affects:</span><span class="val">${affects.join(", ")}</span></div>`;
    }
    if (pt === "corner") {
      // Check if this corner has lower or higher depth than surrounding midpoints
      const cornerTerrain = terrain;
      const adjMids = [];
      if (sx > 0) adjMids.push(getSg(sx - 1, sy)); // left midpoint
      if (sx < sgSize - 1) adjMids.push(getSg(sx + 1, sy)); // right midpoint
      if (sy > 0) adjMids.push(getSg(sx, sy - 1)); // above midpoint
      if (sy < sgSize - 1) adjMids.push(getSg(sx, sy + 1)); // below midpoint
      const surroundSame = adjMids.length > 0 && adjMids.every(t => t === cornerTerrain);
      if (surroundSame) {
        html += `<div style="color:#666; font-size:11px; margin-top:4px">Corner matches neighbors — no blend here</div>`;
      } else if (adjMids.length > 0 && adjMids.every(t => t > cornerTerrain)) {
        html += `<div style="color:#6a6; font-size:11px; margin-top:4px">Lower depth than neighbors → visible as concave cutout in surrounding terrain</div>`;
      } else if (adjMids.length > 0 && adjMids.every(t => t < cornerTerrain)) {
        html += `<div style="color:#c84; font-size:11px; margin-top:4px">Higher depth than neighbors → diagonal bit stripped, invisible alone. Paint adjacent midpoints to make visible.</div>`;
      } else {
        html += `<div style="color:#88a; font-size:11px; margin-top:4px">Corner (diagonal): visibility depends on depth relative to adjacent midpoints</div>`;
      }
    }
    pointDiv.innerHTML = html;
  } else {
    pointDiv.innerHTML = `<span style="color:#666">Hover over a point</span>`;
  }
}

function maskGridHtml(mask) {
  const bits = [
    [AB.NW, "NW"], [AB.N, "N"], [AB.NE, "NE"],
    [AB.W, "W"],   [0, "\u00b7"],  [AB.E, "E"],
    [AB.SW, "SW"], [AB.S, "S"], [AB.SE, "SE"],
  ];
  let html = '<div class="mask-grid">';
  for (const [bit, label] of bits) {
    if (bit === 0) {
      html += `<div class="bit center">${label}</div>`;
    } else {
      const on = (mask & bit) !== 0;
      html += `<div class="bit ${on ? "on" : "off"}">${label}</div>`;
    }
  }
  html += "</div>";
  return html;
}

// ===================== INTERACTION =====================

canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const { sx, sy } = canvasToSg(mx, my);

  // Check if near a sub-grid point
  if (sx >= 0 && sx < sgSize && sy >= 0 && sy < sgSize) {
    const { x: px, y: py } = sgToCanvas(sx, sy);
    const dist = Math.hypot(mx - px, my - py);
    if (dist < CELL * 0.4) {
      hoveredPoint = { sx, sy };
    } else {
      hoveredPoint = null;
    }
  } else {
    hoveredPoint = null;
  }

  hoveredTile = canvasToTile(mx, my);

  if (painting) doPaint(e);

  render();
  updateInfo();
});

canvas.addEventListener("mouseleave", () => {
  hoveredPoint = null;
  hoveredTile = null;
  painting = false;
  render();
  updateInfo();
});

canvas.addEventListener("mousedown", (e) => {
  e.preventDefault();
  painting = true;
  paintButton = e.button;
  doPaint(e);
});

canvas.addEventListener("mouseup", () => { painting = false; });
canvas.addEventListener("contextmenu", (e) => e.preventDefault());

function doPaint(_e) {
  if (!hoveredPoint) return;
  const { sx, sy } = hoveredPoint;
  const pts = getBrushPoints(sx, sy);

  if (paintButton === 2) {
    // Right-click: always paint baseTerrain (universal eraser)
    for (const p of pts) setSg(p.sx, p.sy, baseTerrain);
  } else if (brushMode === "unpaint") {
    // Unpaint: replace matching points with most common adjacent terrain
    for (const p of pts) {
      if (getSg(p.sx, p.sy) === paintTerrain) {
        setSg(p.sx, p.sy, findUnpaintReplacement(p.sx, p.sy));
      }
    }
  } else {
    // Positive / Negative: paint normally (negative only affects resolve)
    for (const p of pts) setSg(p.sx, p.sy, paintTerrain);
  }
  render();
  updateInfo();
  updateUrl();
}

// ===================== REFERENCE GRID =====================

function renderReference(usedMasks) {
  const grid = document.getElementById("refGrid");
  if (grid.children.length === 0) buildReferenceGrid();

  // Update highlighting
  for (const cell of grid.children) {
    const mask = parseInt(cell.dataset.mask, 10);
    cell.classList.toggle("highlight", usedMasks.has(mask));
  }
}

function buildReferenceGrid() {
  const grid = document.getElementById("refGrid");
  grid.innerHTML = "";

  // Build a col,row → mask map from GM_BLOB_47
  const posMap = new Map();
  for (const [mask, col, row] of GM_BLOB_47) posMap.set(row * 12 + col, mask);

  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 12; col++) {
      const cell = document.createElement("div");
      cell.className = "ref-cell";
      const mask = posMap.get(row * 12 + col);

      if (mask === undefined) {
        // Unused cell (0,0)
        cell.classList.add("unused");
        cell.innerHTML = `<canvas width="48" height="48" style="width:48px;height:48px"></canvas><div class="mask-num">--</div>`;
        cell.dataset.mask = "-1";
      } else {
        // Render tile from sheet
        const c = document.createElement("canvas");
        c.width = 48; c.height = 48; c.style.width = "48px"; c.style.height = "48px";
        c.style.imageRendering = "pixelated";
        const rc = c.getContext("2d");

        // Draw base + blend from a representative sheet
        const file = "me-autotile-15.png"; // grass/water - good contrast
        const img = getSheet(file);
        const drawIt = () => {
          rc.imageSmoothingEnabled = false;
          // Draw secondary (water) as base
          rc.fillStyle = TERRAINS[1].color; // ShallowWater
          rc.fillRect(0, 0, 48, 48);
          const baseFile = BASE_SHEET[1];
          const baseImg = getSheet(baseFile);
          if (baseImg.complete && baseImg.naturalWidth) {
            rc.drawImage(baseImg, 1 * 16, 0 * 16, 16, 16, 0, 0, 48, 48);
          }
          // Draw the blend tile on top
          if (img.complete && img.naturalWidth) {
            rc.drawImage(img, col * 16, row * 16, 16, 16, 0, 0, 48, 48);
          }
        };
        if (img.complete) drawIt();
        else img.addEventListener("load", drawIt);

        cell.appendChild(c);
        const label = document.createElement("div");
        label.className = "mask-num";
        label.textContent = mask;
        cell.appendChild(label);
        cell.dataset.mask = mask;
        cell.title = `Mask ${mask} (0b${mask.toString(2).padStart(8, "0")}) at [${col},${row}]`;
      }

      grid.appendChild(cell);
    }
  }
}

// ===================== PRESETS =====================

// Helper: center tile's sub-grid center
function ctr() { const t = Math.floor(gridSize / 2); return { cx: 2*t+1, cy: 2*t+1 }; }

const PRESETS = [
  {
    name: "Single midpoint",
    desc: "One H-midpoint painted → thin edge on 2 tiles. The fundamental unit of sub-grid painting.",
    setup: (g) => { const {cx,cy} = ctr(); g[sgIdx(cx, cy-1)] = paintTerrain; }
  },
  {
    name: "Lone corner",
    desc: "One corner painted. If LOWER depth than surroundings (e.g. water in grass): visible as concave cutout. If HIGHER depth (e.g. dirt in grass): invisible — diagonal bit stripped.",
    setup: (g) => { const {cx,cy} = ctr(); g[sgIdx(cx-1, cy-1)] = paintTerrain; }
  },
  {
    name: "Corner + 2 mids",
    desc: "Corner + 2 adjacent midpoints → convex corner shape (mask 19). The minimum to make a corner visible.",
    setup: (g) => { const {cx,cy} = ctr(); g[sgIdx(cx-1, cy-1)] = paintTerrain; g[sgIdx(cx, cy-1)] = paintTerrain; g[sgIdx(cx-1, cy)] = paintTerrain; }
  },
  {
    name: "L-shape (no diag)",
    desc: "Two adjacent midpoints (N+W) without corner → L-shape (mask 3). IMPOSSIBLE with old corner system!",
    setup: (g) => { const {cx,cy} = ctr(); g[sgIdx(cx, cy-1)] = paintTerrain; g[sgIdx(cx-1, cy)] = paintTerrain; }
  },
  {
    name: "Cross (N+S)",
    desc: "Opposite midpoints (N+S) → cross shape (mask 9). Also impossible with corners — requires independent cardinals.",
    setup: (g) => { const {cx,cy} = ctr(); g[sgIdx(cx, cy-1)] = paintTerrain; g[sgIdx(cx, cy+1)] = paintTerrain; }
  },
  {
    name: "Single cardinal (N)",
    desc: "One H-midpoint above center tile → just the N bit (mask 1). Thinnest possible horizontal edge.",
    setup: (g) => { const {cx,cy} = ctr(); g[sgIdx(cx, cy-1)] = paintTerrain; }
  },
  {
    name: "Full ring",
    desc: "All 8 neighbors of center tile → mask 255 (full fill). Same as painting a whole tile.",
    setup: (g) => {
      const {cx,cy} = ctr();
      for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        g[sgIdx(cx+dx, cy+dy)] = paintTerrain;
      }
    }
  },
  {
    name: "All cardinals",
    desc: "4 midpoints (N/S/W/E) but no corners → mask 15 (cross, all cardinals, no diagonals).",
    setup: (g) => {
      const {cx,cy} = ctr();
      g[sgIdx(cx, cy-1)] = paintTerrain; g[sgIdx(cx, cy+1)] = paintTerrain;
      g[sgIdx(cx-1, cy)] = paintTerrain; g[sgIdx(cx+1, cy)] = paintTerrain;
    }
  },
  {
    name: "Thin river",
    desc: "A horizontal line of midpoints across the grid → thin river running east-west.",
    setup: (g) => {
      const {cy} = ctr();
      for (let sx = 0; sx < sgSize; sx++) g[sgIdx(sx, cy-1)] = paintTerrain;
    }
  },
  {
    name: "Diagonal path",
    desc: "Midpoints placed diagonally → demonstrates how diagonal painting creates varied mask patterns.",
    setup: (g) => {
      for (let i = 1; i < sgSize - 1; i++) {
        g[sgIdx(i, i)] = paintTerrain;
        if (i + 1 < sgSize) g[sgIdx(i + 1, i)] = paintTerrain;
      }
    }
  },
];

function buildPresets() {
  const row = document.getElementById("presetRow");
  for (const p of PRESETS) {
    const btn = document.createElement("button");
    btn.className = "preset-btn";
    btn.textContent = p.name;
    btn.addEventListener("click", () => {
      clearGrid();
      p.setup(subgrid);
      document.getElementById("presetDesc").textContent = p.desc;
      render();
      updateInfo();
      updateUrl();
    });
    btn.addEventListener("mouseenter", () => {
      document.getElementById("presetDesc").textContent = p.desc;
    });
    row.appendChild(btn);
  }
}

// ===================== URL STATE =====================

function encodeState() {
  let data = "";
  for (let i = 0; i < subgrid.length; i++) data += subgrid[i].toString();
  const modeCode = { positive: 0, negative: 1, unpaint: 2 }[brushMode] || 0;
  return `#g=${gridSize}&b=${baseTerrain}&p=${paintTerrain}&m=${modeCode}&d=${data}`;
}

function decodeState(hash) {
  if (!hash || hash.length < 2) return false;
  const params = new URLSearchParams(hash.slice(1));
  const g = parseInt(params.get("g"), 10);
  const b = parseInt(params.get("b"), 10);
  const p = parseInt(params.get("p"), 10);
  const d = params.get("d");
  if (!g || g < 2 || g > 6) return false;

  gridSize = g;
  sgSize = 2 * gridSize + 1;
  subgrid = new Uint8Array(sgSize * sgSize);
  if (b >= 0 && b < 7) baseTerrain = b;
  if (p >= 0 && p < 7) paintTerrain = p;
  const m = parseInt(params.get("m"), 10);
  if (m === 1) brushMode = "negative";
  else if (m === 2) brushMode = "unpaint";
  else brushMode = "positive";

  // Fill with base
  subgrid.fill(baseTerrain);

  // Apply data
  if (d && d.length === subgrid.length) {
    for (let i = 0; i < d.length; i++) {
      const v = parseInt(d[i], 10);
      if (v >= 0 && v < 7) subgrid[i] = v;
    }
  }
  return true;
}

function updateUrl() {
  history.replaceState(null, "", encodeState());
}

// ===================== CONTROLS =====================

function buildPalette() {
  const pal = document.getElementById("palette");
  pal.innerHTML = "";
  for (const t of TERRAINS) {
    const sw = document.createElement("div");
    sw.className = `swatch${t.id === paintTerrain ? " active" : ""}`;
    sw.style.background = t.color;
    sw.title = t.label;
    sw.dataset.id = t.id;
    sw.addEventListener("click", () => {
      paintTerrain = t.id;
      for (const s of document.querySelectorAll(".palette .swatch")) s.classList.toggle("active", parseInt(s.dataset.id, 10) === paintTerrain);
      updateUrl();
    });
    pal.appendChild(sw);
  }
}

function buildBaseSel() {
  const sel = document.getElementById("baseSel");
  sel.innerHTML = "";
  for (const t of TERRAINS) {
    const opt = document.createElement("option");
    opt.value = t.id;
    opt.textContent = t.label;
    if (t.id === baseTerrain) opt.selected = true;
    sel.appendChild(opt);
  }
  sel.addEventListener("change", () => {
    baseTerrain = parseInt(sel.value, 10);
    updateUrl();
  });
}

function clearGrid() {
  subgrid.fill(baseTerrain);
}

document.getElementById("clearBtn").addEventListener("click", () => {
  clearGrid();
  document.getElementById("presetDesc").textContent = "";
  render();
  updateInfo();
  updateUrl();
});

document.getElementById("shareBtn").addEventListener("click", () => {
  updateUrl();
  const url = location.href;
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById("shareBtn");
    btn.textContent = "Copied!";
    setTimeout(() => { btn.textContent = "Copy URL"; }, 1500);
  });
});

document.getElementById("gridSel").addEventListener("change", (e) => {
  gridSize = parseInt(e.target.value, 10);
  sgSize = 2 * gridSize + 1;
  subgrid = new Uint8Array(sgSize * sgSize);
  subgrid.fill(baseTerrain);
  resizeCanvas();
  // Rebuild reference grid (sizes may change)
  document.getElementById("refGrid").innerHTML = "";
  render();
  updateInfo();
  updateUrl();
});

document.getElementById("showSheets").addEventListener("change", (e) => {
  showSheets = e.target.checked;
  render();
});

document.getElementById("showMasks").addEventListener("change", (e) => {
  showMasks = e.target.checked;
  render();
});

// Mode buttons
function setMode(mode) {
  brushMode = mode;
  for (const b of document.querySelectorAll("#modeRow .brush-btn"))
    b.classList.toggle("active", b.dataset.mode === mode);
  render();
  updateInfo();
}
for (const btn of document.querySelectorAll("#modeRow .brush-btn")) {
  btn.addEventListener("click", () => setMode(btn.dataset.mode));
}

// Shape buttons
function setShape(shape) {
  brushShape = shape;
  for (const b of document.querySelectorAll("#shapeRow .brush-btn"))
    b.classList.toggle("active", b.dataset.shape === shape);
  render();
}
for (const btn of document.querySelectorAll("#shapeRow .brush-btn")) {
  btn.addEventListener("click", () => setShape(btn.dataset.shape));
}

// Keyboard shortcuts
document.addEventListener("keydown", (e) => {
  const key = e.key.toLowerCase();
  if (key === "z") { setMode("positive"); return; }
  if (key === "x") { setMode("negative"); return; }
  if (key === "c") { setMode("unpaint"); return; }
  const shapeKeys = { "1": "grid1", "2": "grid2", "3": "grid3", "4": "cross", "5": "tile" };
  if (shapeKeys[key]) { setShape(shapeKeys[key]); return; }
});

// ===================== INIT =====================

function init() {
  // Try to restore from URL
  if (!decodeState(location.hash)) {
    subgrid.fill(baseTerrain);
  }

  // Sync controls with state
  document.getElementById("gridSel").value = gridSize;
  buildPalette();
  buildBaseSel();
  // Sync mode buttons with restored state
  for (const b of document.querySelectorAll("#modeRow .brush-btn"))
    b.classList.toggle("active", b.dataset.mode === brushMode);
  buildPresets();
  resizeCanvas();
  render();
  updateInfo();

  // Preload commonly used sheets
  for (const file of Object.values(BASE_SHEET)) getSheet(file);
  getSheet("me-autotile-12.png");
  getSheet("me-autotile-13.png");
  getSheet("me-autotile-10.png");
}

init();
</script>
</body></html>
